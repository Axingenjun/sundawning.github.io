<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <title>
      White3DTilesetStyle - LINEARtoSRGB -
      model._rendererResources.sourceShaders - 仿百度 - 上海市区城市白模
    </title>
    <link
      rel="shortcut icon"
      href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQBAMAAAAVaP+LAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAhUExUReHY5f///y8qMS0oL/Hu8khCSdHL02ZgZ4R9hKGaobqzux+9hjkAAASdSURBVGje7ZrPa9xGFMefQW0Tn9Yg3NrHGYzXVw3CuS4IJ+5xl7aOT7q0TXwqMWmcnoxNkm1PJtA46WkpmLr9K7vSajS/3ozmSb6Ues7io/f9zpufb2Djjhrcg+5B/1dQOrkDUFGsf/p49iEpiiGg4uTvd6+mjIud30qADpgflD5/OWVCCMYYz3+Buk16gA6upyJjTeP567ImFWTQ1294i6lIWUNKJjTQwxeCGa2ThILSZ1OLU5EanzxGYaDRX9OMOY3nbxtSEQlKrznCWZJ2ywAJAT3BOYy14jB1LmjzhYfDWL6QpAhQeuPlMP5UgpJu0APO/C2/8oqDeGFVSOPSR4J4YbXfb33iwO6xIEdLATskIAirQ/oZ8J4DijAzpMQPOuSssymXwA/qDmgZ0l4LWvOBNmcsoqn0TnygL7IYEFd2T3BQesGiQEpbgoO2eBSI7ZdYSECzum7nYVCc1ZW2Y0ybAj2ODQjXBkSr65y8QkICqtWVtm/BzW4gW71sY3C1SdBoFs/RTUps0BaBo40SpQ1Iw0O2K1ebBL2ncPhP4EwBDSg9JYG0bktM0DYngY69oMcki5iaAFqTgJ5FZiKZoPSSxNETSboNtJEvE6l0TFqBvmJE0MID+oxmEcsWjklAT8cAiJaONmhNgaheGx41Jq1A/I5A24z17/5mJoE+ve8HEXvfyOym28A/ZLkQGRc4CHAQmo8i++ZsPn/JKaDvEZDY+fWHpYCTN3wYiO9+WH21fpGF56MmI2vQn5mXA/BwFpwhDZC7Wudqpwi/Z4G9lgm69B86qpB4aDmSqV2DToND4PPTcBop0Og07MH7zLv5M0HO4M/N0H/Mghb5QfYfH4T/sxpsKMj6o+32GCIjMqyucnIW/I8/IkuZ3W32fxRo1PXHy0CX6tKsuT+zvQRjCDlWawl5GUo3q/+NpA+C7M633Hbj1UAXYYsAbtqJUrgBaSDDA+SXsC7PuuK7RQhkTGx56X4Kz2ZZffVzhHC0acSYs/cBa7dTIcTOGcbRQMYq8ggFwfP52fyPEsKgLyNAgTbBF8ghIOP8MARk7EYGgWaDQGoTMborkLGMkEGJZzM6poLWPNvjvV5eN6AtNgDkO0KMe1kkDzXajLQ7BKQfs/Kyj0XIwW8YSDuKZos+yrDD8fkQkJaS/LyPMuQCQT+L9wBtBZbkGGUtSEvJ8SDQhtrf7Zc9lCnQk+AK2RmQAqkdKbZmE0BqueV7PZRpoO0Z3ST0+jBt7c7OaZOjfTPaXtPHZxJ+V6vsfkRXZlxDtzu8/IpqtediPDYBOq/q+ZhqtQVqr1nzBVWZVc6QGRClLVDO2DiULo1LYkB2yUe6pFU/ohxyQLLmoxVkooS5ZTFZXlNlwihhLiiVh/P9cMcVnRW/VtwxRRhWzJTiQuMEKR+7oPRmReJH8QbhddrNC9GRApEF343DVUWc7y5iDfIVxZsavXhaxsbjK9MfXNfHKlmaj+D46v3pbVWo5wiJ+HCgehGxlOeQvA8QAo8rDq65ENaZMen13CO9rZ9pHMlLsiQp+j5AGZ38M3/36nVZVG0y8ElMxbh/NnQP+s+B/gW3UDTN+m1LRgAAAABJRU5ErkJggg=="
    />
  </head>
  <body>
    <!-- Cesium界面-->
    <link
      rel="stylesheet"
      href="./node_modules/cesium/Build/CesiumUnminified/Widgets/widgets.css"
    />
    <style>
      #container {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
      }
    </style>
    <div id="container"></div>
    <script
      type="text/javascript"
      src="./node_modules/cesium/Build/CesiumUnminified/Cesium.js"
    ></script>
    <!-- 创建Cesium场景 -->
    <script type="text/javascript">
      const container = document.querySelector("#container");
      const viewer = new Cesium.Viewer(container, {
        baseLayerPicker: false,
        imageryProvider: new Cesium.ArcGisMapServerImageryProvider({
          url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer",
        }),
      });
    </script>
    <!-- 添加模型 -->
    <script type="text/javascript">
      const tileset = new Cesium.Cesium3DTileset({
        url: "https://data.mars3d.cn/3dtiles/jzw-shanghai/tileset.json",
        // shadows: Cesium.ShadowMode.DISABLED,
        // lightColor: new Cesium.Cartesian3(1, 1, 1),''
        // showOutline: false,
      });
      viewer.scene.primitives.add(tileset);
    </script>
    <!-- 初始视角 -->
    <script type="text/javascript">
      // 使用模型视角
      // tileset.readyPromise.then(function (tileset) {
      //   viewer.camera.flyToBoundingSphere(tileset.boundingSphere, {
      //     duration: 0,
      //   });
      // });
      // 使用自定义视角
      viewer.camera.setView({
        destination: {
          x: -2851045.4074052866,
          y: 4654456.610110114,
          z: 3289122.790063821,
        },
        orientation: {
          heading: 1.9822013104933793,
          pitch: -0.47942367195068814,
          roll: 0.000004410721189174183,
        },
      });
    </script>
    <!-- 修改白模 -->
    <script type="text/javascript">
      /**
       * 修改白模颜色
       * @version v0.0.2
       * @param {Cesium.Cesium3DTileset} tileset
       * @param {string} cssColorString 形如“#fff”
       * @author 孙曙光 <jobsimi@qq.com>
       * @example
       * // 给白模应用颜色修改
       * let white3DTilesetStyle = new White3DTilesetStyle(tileset, "#fff");
       * // 还原白模的颜色修改
       * white3DTilesetStyle.destroy();
       * // 再次应用颜色修改
       * white3DTilesetStyle.apply();
       */
      class White3DTilesetStyle {
        /**
         * @param {Cesium.Cesium3DTileset} tileset
         * @param {string} cssColorString 形如“#fff”
         */
        constructor(tileset, cssColorString) {
          this.tileset = tileset;
          this.cssColorString = cssColorString;
          this.isApply = false;
          this.initSetting = {};
          this.apply();
        }
        /**
         * 还原白模颜色修改
         */
        destroy() {
          const { style, fragmentShader } = this.initSetting;
          this.tileset.style = style;
          this.tileset.tileVisible.addEventListener(function (tile) {
            const content = tile.content;
            const featuresLength = content.featuresLength;
            for (let i = 0; i < featuresLength; i += 2) {
              let feature = content.getFeature(i);
              let model = feature.content._model;
              if (model && model._sourcePrograms && model._rendererResources) {
                Object.keys(model._sourcePrograms).forEach((key) => {
                  let program = model._sourcePrograms[key];
                  model._rendererResources.sourceShaders[
                    program.fragmentShader
                  ] = fragmentShader;
                });
                model._shouldRegenerateShaders = true;
              }
            }
          });
        }
        /**
         * 应用白模颜色修改
         */
        apply() {
          const $this = this;
          this.initSetting.style = this.tileset.style; // 保存3DTileset原有的样式，便于还原。
          this.tileset.style = new Cesium.Cesium3DTileStyle({
            color: {
              conditions: [
                ["true", `color(${JSON.stringify(this.cssColorString)})`],
              ],
            },
          });
          if (this.isLightColor(this.cssColorString) === true) {
            this.tileset.tileVisible.addEventListener(function (tile) {
              const content = tile.content;
              const featuresLength = content.featuresLength;
              for (let i = 0; i < featuresLength; i += 2) {
                let feature = content.getFeature(i);
                let model = feature.content._model;
                if (
                  model &&
                  model._sourcePrograms &&
                  model._rendererResources
                ) {
                  // 保存3DTileset原有的shader，便于还原。
                  if ($this.isApply === false) {
                    $this.isApply = true;
                    $this.initSetting.fragmentShader =
                      model._rendererResources.sourceShaders[1];
                  }
                  Object.keys(model._sourcePrograms).forEach((key) => {
                    let program = model._sourcePrograms[key];
                    let v_position = "";
                    const fragmentShader =
                      model._rendererResources.sourceShaders[
                        program.fragmentShader
                      ];
                    if (fragmentShader.indexOf(" v_positionEC;") != -1) {
                      v_position = "v_positionEC";
                    } else if (fragmentShader.indexOf(" v_pos;") != -1) {
                      v_position = "v_pos";
                    }
                    model._rendererResources.sourceShaders[
                      program.fragmentShader
                    ] = `
precision highp float;
uniform vec4 u_baseColorFactor;
uniform float u_metallicFactor;
uniform float u_roughnessFactor;
uniform vec3 u_emissiveFactor;
varying vec3 v_normal;
varying vec3 ${v_position};
const float M_PI = 3.141592653589793;
vec3 lambertianDiffuse(vec3 diffuseColor) 
{
    return diffuseColor / M_PI;
}

vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) 
{
    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);
}

vec3 fresnelSchlick(float metalness, float VdotH) 
{
    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);
}

float smithVisibilityG1(float NdotV, float roughness) 
{
    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float smithVisibilityGGX(float roughness, float NdotL, float NdotV) 
{
    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);
}

float GGX(float roughness, float NdotH) 
{
    float roughnessSquared = roughness * roughness;
    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;
    return roughnessSquared / (M_PI * f * f);
}

vec3 SRGBtoLINEAR3(vec3 srgbIn) 
{
    return pow(srgbIn, vec3(2.2));
}

vec4 SRGBtoLINEAR4(vec4 srgbIn) 
{
    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));
    return vec4(linearOut, srgbIn.a);
}

vec3 applyTonemapping(vec3 linearIn) 
{
#ifndef HDR 
    return czm_acesTonemapping(linearIn);
#else 
    return linearIn;
#endif 
}

vec3 LINEARtoSRGB(vec3 linearIn) 
{
#ifndef HDR 
    return pow(linearIn, vec3(1.0/10.1));
#else 
    return linearIn;
#endif 
}

vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) 
{
    rotation = -rotation; 
    mat3 transform = mat3(
        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, 
       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, 
        offset.x, offset.y, 1.0); 
    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; 
    return transformedTexCoords; 
}

#ifdef USE_IBL_LIGHTING 
uniform vec2 gltf_iblFactor; 
#endif 
#ifdef USE_CUSTOM_LIGHT_COLOR 
uniform vec3 gltf_lightColor; 
#endif 
void main(void) 
{
    vec3 ng = normalize(v_normal);
    vec3 positionWC = vec3(czm_inverseView * vec4(${v_position}, 1.0));
    vec3 n = ng;
    if (czm_backFacing())
    {
        n = -n;
    }
    vec4 baseColorWithAlpha = u_baseColorFactor;
    vec3 baseColor = baseColorWithAlpha.rgb;
    float metalness = clamp(u_metallicFactor, 0.0, 1.0);
    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);
    vec3 v = -normalize(${v_position});
#ifndef USE_CUSTOM_LIGHT_COLOR 
    vec3 lightColorHdr = czm_lightColorHdr;
#else 
    vec3 lightColorHdr = gltf_lightColor;
#endif 
    vec3 l = normalize(czm_lightDirectionEC);
    vec3 h = normalize(v + l);
    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = abs(dot(n, v)) + 0.001;
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);
    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);
    vec3 specularColor = mix(f0, baseColor, metalness);
    float alpha = roughness * roughness;
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));
    vec3 r0 = specularColor.rgb;
    vec3 F = fresnelSchlick2(r0, r90, VdotH);
    float G = smithVisibilityGGX(alpha, NdotL, NdotV);
    float D = GGX(alpha, NdotH);
    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);
    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);
    vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);
#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) 
    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));
    float vertexRadius = length(positionWC);
    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);
    float reflectionDotNadir = dot(r, normalize(positionWC));
    r.x = -r.x;
    r = -normalize(czm_temeToPseudoFixed * r);
    r.x = -r.x;
    float inverseRoughness = 1.04 - roughness;
    inverseRoughness *= inverseRoughness;
    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;
    float atmosphereHeight = 0.05;
    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);
    float blendRegionOffset = roughness * -1.0;
    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);
    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);
    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);
    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);
    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);
    vec3 nadirColor = belowHorizonColor * 0.5;
    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);
    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);
    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);
    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);
    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;
    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));
    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);
    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);
    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);
    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);
    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);
#ifdef USE_SUN_LUMINANCE 
    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);
    float S = acos(LdotZenith);
    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);
    float gamma = acos(NdotL);
    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));
    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));
    float luminance = gltf_luminanceAtZenith * (numerator / denominator);
#endif 
    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;
    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);
    float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);
    vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);
    IBLColor *= lightColor;
#ifdef USE_SUN_LUMINANCE 
    color += IBLColor * luminance;
#else 
    color += IBLColor; 
#endif 
#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) 
    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); 
    vec3 cubeDir = normalize(yUpToZUp * gltf_iblReferenceFrameMatrix * normalize(reflect(-v, n))); 
#ifdef DIFFUSE_IBL 
#ifdef CUSTOM_SPHERICAL_HARMONICS 
    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); 
#else 
    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); 
#endif 
#else 
    vec3 diffuseIrradiance = vec3(0.0); 
#endif 
#ifdef SPECULAR_IBL 
    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;
#ifdef CUSTOM_SPECULAR_IBL 
    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);
#else 
    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);
#endif 
    specularIBL *= F * brdfLut.x + brdfLut.y;
#else 
    vec3 specularIBL = vec3(0.0); 
#endif 
    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;
#endif 
    color += u_emissiveFactor;
    color = applyTonemapping(color);
    color = LINEARtoSRGB(color);
    gl_FragColor = vec4(color, 1.0);
}
`;
                  });
                  model._shouldRegenerateShaders = true;
                }
              }
            });
          }
        }
        /**
         * hex to rgb
         * ————————————————
         * 版权声明：本文为CSDN博主「mossbaoo」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
         * 原文链接：https://blog.csdn.net/mossbaoo/article/details/93484635
         */
        hexToRGB(hex) {
          // 16进制颜色值的正则
          const reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
          // 把颜色值变成小写
          let color = hex.toLowerCase();
          if (reg.test(color)) {
            // 如果只有三位的值，需变成六位，如：#fff => #ffffff
            if (color.length === 4) {
              let colorNew = "#";
              for (let i = 1; i < 4; i += 1) {
                colorNew += color.slice(i, i + 1).concat(color.slice(i, i + 1));
              }
              color = colorNew;
            }
            // 处理六位的颜色值，转为RGB
            const colorChange = [];
            for (let i = 1; i < 7; i += 2) {
              colorChange.push(parseInt("0x" + color.slice(i, i + 2)));
            }
            return colorChange;
          } else {
            return;
          }
        }
        /**
         * 是否是浅色
         * @see https://www.cnblogs.com/qinwei/p/6437800.html
         */
        isLightColor(cssColorString) {
          const rgb = this.hexToRGB(cssColorString);
          if (rgb === undefined) {
            return false;
          }
          const [r, g, b] = rgb;
          const grayLevel = r * 0.299 + g * 0.587 + b * 0.114;
          if (grayLevel >= 192) {
            return true;
          } else {
            return false;
          }
        }
      }
    </script>
    <script type="text/javascript">
      let white3DTilesetStyle = new White3DTilesetStyle(tileset, "#fff");
    </script>
  </body>
</html>
